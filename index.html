<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="baidu-site-verification" content="code-LVoSk3O7dT" />
    <meta name="google-site-verification" content="IO6wWmz-PlovTXvlyGAgYe0hdtVahfCZ1imoG4LbiK8" />
    <title>Guanxing Lu | 卢冠行</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #scoreCounter {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        
        /* Add new styles for navigation */
        #navigation {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        .nav-button {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .nav-button:hover {
            background-color: rgba(255, 255, 255, 1);
        }
        
        .nav-button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        /* Update styles for social icons to be centered */
        .social-icons {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            z-index: 100;
            display: flex;
            gap: 15px;
        }
        
        .social-icon {
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            transition: color 0.3s;
            text-decoration: none;
        }
        
        .social-icon:hover {
            color: rgba(255, 255, 255, 1);
        }
        
        /* Content sections */
        .content-section {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 99;
            line-height: 1.6;
        }
        
        .content-section h2 {
            margin-bottom: 25px;
        }
        
        .content-section h3 {
            color: #333;
            margin-top: 25px;
        }
        
        /* Link styles from index_old.html */
        a {
            text-decoration: none;
            color: #1772d0;
        }
        
        a:focus, a:hover {
            color: #f09228;
        }
        
        /* Publication styling */
        .publication {
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .publication-thumbnail {
            width: 150px;  /* Fixed width */
            min-height: 100px;  /* Minimum height */
            max-height: 150px; /* Maximum height */
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-top: 15px;  /* Added margin to move thumbnails slightly down */
        }
        
        .publication-thumbnail video {
            width: 100%;
            height: 150px;  /* Fixed height for videos */
            object-fit: cover;
        }
        
        .publication-thumbnail img {
            width: 100%;
            height: auto;  /* Auto height for images */
            display: block;
        }
        
        .publication-content {
            flex: 1;
        }
        
        .publication-content h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #333;
        }
        
        .publication-content p {
            margin: 8px 0;
            line-height: 1.4;
        }
        
        .publication.highlight {
            background: linear-gradient(to right, rgba(240, 248, 255, 0.8), rgba(255, 255, 255, 0.9));
            margin: 0 -20px 30px -20px;  /* Negative margin to align with container */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .publication.highlight:hover {
            background: linear-gradient(to right, rgba(230, 240, 255, 0.9), rgba(255, 255, 255, 0.95));
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Profile section styling */
        .profile-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            margin: 20px auto;
            display: block;
            border-radius: 8px;
        }
    </style>
    <!-- Add Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <meta name="author" content="GuanXing Lu | 卢冠行">
    <link rel="icon" href="images/lgx_icon_low.png">
</head>
<body>
    <!-- Add social icons -->
    <div class="social-icons">
        <a href="https://github.com/GuanxingLu" class="social-icon" target="_blank">
            <i class="fab fa-github"></i>
        </a>
        <a href="https://scholar.google.com/citations?user=b9n4SrMAAAAJ&hl=en&oi=ao" class="social-icon" target="_blank">
            <i class="fas fa-graduation-cap"></i>
        </a>
        <a href="https://x.com/gxlu02" class="social-icon" target="_blank">
            <i class="fab fa-x-twitter"></i>
        </a>
        <a href="https://www.linkedin.com/in/guanxing-lu-0402552a6/" class="social-icon" target="_blank">
            <i class="fab fa-linkedin"></i>
        </a>
        <a href="https://www.xiaohongshu.com/user/profile/644a1a3600000000100257e8" class="social-icon" target="_blank">
            <i class="fas fa-book-open"></i>
        </a>
        <a href="https://www.zhihu.com/people/lu-guan-xing-81" class="social-icon" target="_blank">
            <i class="fab fa-zhihu"></i>
        </a>
        <a href="mailto:lgx23@mails.tsinghua.edu.cn" class="social-icon">
            <i class="fas fa-envelope"></i>
        </a>
    </div>

    <div id="navigation">
        <button class="nav-button" data-section="about">About Me</button>
        <button class="nav-button" data-section="papers">Papers</button>
        <button class="nav-button" data-section="misc">Misc</button>
    </div>
    
    <div id="about" class="content-section">
        <h2>About Me</h2>
        <img src="images/DSC00622.jpg" alt="Guanxing Lu" class="profile-image">
        <p style="text-align: center; color: #666; font-style: italic; margin-top: -10px; margin-bottom: 20px;">
            Taken in Shenzhen, 2024.
        </p>
        <p>Hello! I am a Master's student at <a href="https://www.sigs.tsinghua.edu.cn/">Tsinghua University Shenzhen International Graduate School</a>, <a href="https://www.tsinghua.edu.cn/">Tsinghua University</a>. I am fortunate to be supervised by Prof. <a href="https://andytang15.github.io/">Yansong Tang</a> in IVG@SZ group and Prof. <a href="https://ziweiwangthu.github.io/">Ziwei Wang</a> in <a href="https://pine-lab-ntu.github.io/">PINE</a> group at NTU. I have spent unforgetable time working at General Vision Lab in <a href="https://www.bigai.ai/">BIGAI</a> as a research intern advised by <a href="https://buzz-beater.github.io/">Dr. Baoxiong Jia</a> and <a href="https://siyuanhuang.com/">Dr. Siyuan Huang</a>. I received my bachelor's degree in <a href="https://wjx.seu.edu.cn/">Chien-Shiung Wu College</a> from <a href="https://www.seu.edu.cn/">Southeast University</a>, where I was a member of <a href="http://palm.seu.edu.cn/">PALM</a> lab and advised by Prof. <a href="https://jyh-learning.github.io/">Yuheng Jia</a> and Prof. <a href="https://sites.google.com/site/junhuihoushomepage/biography">Junhui Hou</a>.
        </p>
        <p>
        My research passion is on <strong>"helping robots teach themselves"</strong>. If you would like to chat about life or research ideas on 3D vision/robotics, feel free to contact me, I am always open to these conversations.
        </p>
    </div>
    
    <div id="papers" class="content-section">
        <h2>Selected Publications</h2>

        <!-- VLA-RL -->
        <div class="publication highlight">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/vlarl_avg_libero.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>VLA-RL: Towards Masterful and General Robotic Manipulation with Scalable Reinforcement Learning</h3>
                <p><strong>Guanxing Lu</strong>, Wenkai Guo, Chubin Zhang, Yuheng Zhou, Haonan Jiang, Zifeng Gao, Yansong Tang<sup>†</sup>, Ziwei Wang</p>
                <p><em>Preprint 2025</em></p>
                <p>
                    <a href="https://arxiv.org/html/2505.18719v1">arxiv</a> /
                    <a href="https://github.com/GuanxingLu/vlarl">code</a>
                </p>
            </div>
        </div>
        
        <!-- ManiGaussian++ -->
        <div class="publication">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/mgpp_press_handsan_success.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>ManiGaussian++: Dynamic Gaussian Splatting for Multi-task Bimanual Manipulation</h3>
                <p>Tengbo Yu<sup>*</sup>, <strong>Guanxing Lu<sup>*</sup></strong>, Zaijia Yang<sup>*</sup>, Haoyuan Deng, Season Si Chen, Jiwen Lu, Wenbo Ding, Guoqiang Hu, Yansong Tang<sup>†</sup>, Ziwei Wang</p>
                <p><em>IROS 2025</em></p>
                <p>
                    <a href="#">arxiv</a> /
                    <a href="#">code</a>
                </p>
            </div>
        </div>

        <!-- AnyBimanual -->
        <div class="publication highlight">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/anybimanual_v2.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>AnyBimanual: Transferring Unimanual Policy for General Bimanual Manipulation</h3>
                <p><strong>Guanxing Lu</strong><sup>*</sup>, Tengbo Yu<sup>*</sup>, Haoyuan Deng, Season Si Chen, Yansong Tang<sup>†</sup>, Ziwei Wang</p>
                <p><em>Preprint 2024</em></p>
                <p>
                    <a href="https://anybimanual.github.io/">project page</a> /
                    <a href="https://arxiv.org/abs/2412.06779">arxiv</a> /
                    <a href="https://github.com/TengBoYu01/AnyBimanual">code</a>
                </p>
            </div>
        </div>

        <!-- ManiCM -->
        <div class="publication">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/manicm.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>ManiCM: Real-time 3D Diffusion Policy via Consistency Model for Robotic Manipulation</h3>
                <p><strong>Guanxing Lu</strong><sup>*</sup>, Zifeng Gao<sup>*</sup>, Tianxing Chen, Wenxun Dai, Ziwei Wang, and Yansong Tang</p>
                <p><em>Preprint 2024</em></p>
                <p>
                    <a href="https://manicm-fast.github.io/">project page</a> /
                    <a href="https://arxiv.org/abs/2406.01586">arxiv</a> /
                    <a href="https://github.com/ManiCM-fast/ManiCM">code</a>
                </p>
            </div>
        </div>

        <!-- ManiGaussian -->
        <div class="publication highlight">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/manigaussian.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>ManiGaussian: Dynamic Gaussian Splatting for Multi-task Robotic Manipulation</h3>
                <p><strong>Guanxing Lu</strong>, Shiyi Zhang, Ziwei Wang, Changliu Liu, Jiwen Lu and Yansong Tang</p>
                <p><em>ECCV 2024</em></p>
                <p>
                    <a href="https://guanxinglu.github.io/ManiGaussian">project page</a> /
                    <a href="https://arxiv.org/abs/2403.08321">arxiv</a> /
                    <a href="https://github.com/GuanxingLu/ManiGaussian">code</a> /
                    <a href="https://zhuanlan.zhihu.com/p/708538384">中文解读</a>
                </p>
            </div>
        </div>

        <!-- ThinkBot -->
        <div class="publication">
            <div class="publication-thumbnail">
                <video muted autoplay loop>
                    <source src="images/thinkbot.mp4" type="video/mp4">
                </video>
            </div>
            <div class="publication-content">
                <h3>ThinkBot: Embodied Instruction Following with Thought Chain Reasoning</h3>
                <p><strong>Guanxing Lu</strong>, Ziwei Wang, Changliu Liu, Jiwen Lu and Yansong Tang</p>
                <p><em>ICLR 2025</em></p>
                <p>
                    <a href="https://guanxinglu.github.io/thinkbot">project page</a> /
                    <a href="https://arxiv.org/abs/2312.07062">arxiv</a>
                </p>
            </div>
        </div>

        <!-- Semi-Supervised Subspace Clustering -->
        <div class="publication">
            <div class="publication-thumbnail">
                <img src="images/semi-supervised-subspace-clustering.png" alt="Subspace Clustering">
            </div>
            <div class="publication-content">
                <h3>Semi-Supervised Subspace Clustering via Tensor Low-Rank Representation</h3>
                <p>Yuheng Jia, <strong>Guanxing Lu</strong>, Hui Liu and Junhui Hou</p>
                <p><em>IEEE TCSVT 2023</em></p>
                <p>
                    <a href="https://arxiv.org/pdf/2205.10481">arxiv</a> /
                    <a href="https://github.com/GuanxingLu/Subspace-Clustering">code</a>
                </p>
            </div>
        </div>
    </div>
    
    <div id="misc" class="content-section">
        <h2>Misc</h2>
        <ul>
            <li>🏊️ Swimming: I am a fan of swimming. I have learned four swimming styles by watching videos.</li>
            <li>📖 Reading: Recently, I enjoy reading sci-fi novels. Looking for book friends in Weread!</li>
            <li>🎮 Gaming: I like playing games, now Honkai Star Rail and Valorant.</li>
            <li>🎸 Music: I'm learning bass and piano. I am a fan of rock band.</li>
        </ul>
        <p align="center" style="margin-top: 20px; color: #666;">
            © 2022-2025 <a href="https://guanxinglu.github.io/">Guanxing Lu</a>. Last updated: Feb. 3, 2025.
        </p>
        <p style="color: rgba(255, 255, 255, 0.9); text-align: center;">踏平坎坷成大道，斗罢艰险又出发。</p>
        
        <div style="display: flex; justify-content: center; align-items: center;">
            <script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=MXappg0UE7ClwO9AgInzOCgmbdoURVqJuhVxcmHSwxE&w=200&t=tt"></script>
        </div>
    </div>

    <div id="scoreCounter">Score: 0</div>
    <div id="instructions" style="position: fixed; top: 50px; left: 20px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        Press SPACE to spawn cube<br>
        Move mouse to position cube<br>
        Click to drop cube
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x404040); // Gray background
        document.body.appendChild(renderer.domElement);

        // Lights
        const light = new THREE.DirectionalLight(0xffffff, 1.5); // Increased intensity
        light.position.set(50, 100, 50); // Higher position for sun-like effect
        light.castShadow = true; // Enable shadow casting
        light.shadow.mapSize.width = 2048; // Higher resolution shadows
        light.shadow.mapSize.height = 2048;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 500;
        light.shadow.camera.left = -50;
        light.shadow.camera.right = 50;
        light.shadow.camera.top = 50;
        light.shadow.camera.bottom = -50;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Enable shadow rendering in renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Robot arm parts with longer segments
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 2, 1, 32),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        scene.add(base);

        const joint1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 32, 32),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        joint1.position.y = 0.5;
        base.add(joint1);

        const arm1 = new THREE.Mesh(
            new THREE.BoxGeometry(1, 8, 1),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        arm1.position.y = 4; // Center of the arm
        joint1.add(arm1);

        const joint2 = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 32, 32),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        joint2.position.y = 4;
        arm1.add(joint2);

        const arm2 = new THREE.Mesh(
            new THREE.BoxGeometry(1, 6, 1),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        arm2.position.y = 3;
        joint2.add(arm2);

        // Gripper
        const gripper = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 2),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        gripper.position.y = 3; // Adjusted position
        arm2.add(gripper);

        // Camera position
        camera.position.set(10, 10, 10); // Adjust these values as needed
        camera.lookAt(0, 0, 0); // Ensure the camera is looking at the center of the scene

        // Hyper-parameters
        const ARM1_LENGTH = 8;
        const ARM2_LENGTH = 6;
        const GRAVITY = 0.002;
        const CUBE_SPAWN_INTERVAL_MS = 2000;
        const ARM_BOUNCE_FORCE = 0.2;
        const COLLISION_DAMPING = 0.7;

        // Animation variables
        let cube = null;
        let phase = 'waiting';
        let time = 0;
        let cubeVelocity = 0;
        let lastSpawnTime = 0; // Last cube spawn time
        let score = 0;

        // Add after the lights setup
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(40, 40);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x808080,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true; // Enable shadow receiving
        scene.add(ground);

        // Update constants
        const GROUND_RESTITUTION = 0.6; // Bounce factor for ground collision
        const FRICTION = 0.98; // Friction for horizontal movement
        const ANGULAR_DAMPING = 0.98; // Damping for rotation
        const ROTATION_FACTOR = 0.1; // Factor for converting linear to angular velocity

        // Add these variables to track horizontal movement
        let cubeVelocityX = 0;
        let cubeVelocityZ = 0;

        // Add these variables to track cube physics
        let cubeAngularVelocity = {
            x: 0,
            y: 0,
            z: 0
        };

        // Update robot arm parts to cast shadows
        base.castShadow = true;
        joint1.castShadow = true;
        arm1.castShadow = true;
        joint2.castShadow = true;
        arm2.castShadow = true;
        gripper.castShadow = true;

        // Add these constants and variables for cube management
        const MAX_CUBES = 5; // Maximum number of cubes allowed in the scene
        let cubes = []; // Array to store all active cubes
        let cubePhysicsStates = []; // Array to store physics states for each cube

        // Add these constants for scene boundaries
        // const SCENE_BOUNDS = {
        //     minX: -20,
        //     maxX: 20,
        //     minY: -10,
        //     maxY: 20,
        //     minZ: -20,
        //     maxZ: 20
        // };
        const SCENE_BOUNDS = {
            minX: -11,
            maxX: 11,
            minY: -5,
            maxY: 10,
            minZ: -11,
            maxZ: 11
        };

        // Add this function to check if a cube is out of bounds
        function isOutOfBounds(position) {
            return position.x < SCENE_BOUNDS.minX || position.x > SCENE_BOUNDS.maxX ||
                   position.y < SCENE_BOUNDS.minY || position.y > SCENE_BOUNDS.maxY ||
                   position.z < SCENE_BOUNDS.minZ || position.z > SCENE_BOUNDS.maxZ;
        }

        // Add new control variables
        let isControllingCube = false;
        let mousePosition = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modify createRandomCube function
        function createRandomCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            const newCube = new THREE.Mesh(geometry, material);
            
            if (!isControllingCube) {
                // Original random position logic
                const innerRadius = 2;
                const outerRadius = 4;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * (outerRadius - innerRadius) + innerRadius;
                newCube.position.set(
                    Math.cos(angle) * radius,
                    10,
                    Math.sin(angle) * radius
                );
            } else {
                // Position at mouse location
                newCube.position.copy(mousePosition);
            }
            
            newCube.castShadow = true;
            
            // Add new cube physics state
            const physicsState = {
                velocity: 0,
                velocityX: 0,
                velocityZ: 0,
                angularVelocity: { x: 0, y: 0, z: 0 }
            };

            // Remove oldest cube if we've reached the limit
            if (cubes.length >= MAX_CUBES) {
                scene.remove(cubes[0]);
                cubes.shift();
                cubePhysicsStates.shift();
            }

            // Add new cube
            cubes.push(newCube);
            cubePhysicsStates.push(physicsState);
            scene.add(newCube);
            
            // Set the active cube as the newest one
            cube = newCube;
            cubeVelocity = 0;
            cubeVelocityX = 0;
            cubeVelocityZ = 0;
            cubeAngularVelocity = { x: 0, y: 0, z: 0 };
            
            lastSpawnTime = Date.now();
        }

        // Two-joint IK solver
        function solveIK(targetX, targetY, targetZ) {
            // Convert target to local coordinates
            const dx = Math.sqrt(targetX * targetX + targetZ * targetZ);
            const dy = targetY - 3.5; // Adjust for base height
            
            // Calculate angles using cosine law
            const targetDist = Math.sqrt(dx * dx + dy * dy);
            
            // Prevent over-extension
            const maxReach = ARM1_LENGTH + ARM2_LENGTH;
            if (targetDist > maxReach) {
                const scale = maxReach / targetDist;
                targetDist *= scale;
            }

            const cosAngle2 = (targetDist * targetDist - ARM1_LENGTH * ARM1_LENGTH - ARM2_LENGTH * ARM2_LENGTH) / 
                             (2 * ARM1_LENGTH * ARM2_LENGTH);
            
            // Calculate joint angles
            const angle2 = Math.acos(Math.min(1, Math.max(-1, cosAngle2)));
            const angle1 = Math.atan2(dy, dx) - 
                          Math.atan2(ARM2_LENGTH * Math.sin(angle2),
                                   ARM1_LENGTH + ARM2_LENGTH * Math.cos(angle2));

            return {
                baseAngle: Math.atan2(targetX, targetZ),
                arm1Angle: -angle1,
                arm2Angle: -angle2
            };
        }

        // Predict interception point
        function predictInterceptionPoint(cubePos, cubeVel) {
            // Simple prediction - you can make this more sophisticated
            const timeToIntercept = Math.sqrt(2 * cubePos.y / GRAVITY);
            return new THREE.Vector3(
                cubePos.x,
                Math.max(1, cubePos.y - (cubeVel * timeToIntercept + 0.5 * GRAVITY * timeToIntercept * timeToIntercept)),
                cubePos.z
            );
        }

        // Enhanced collision detection helper function
        function checkArmCubeCollision(cube) {
            const cubePos = cube.position;
            const collisionPoints = [];
            
            // Get world positions of all arm segments
            const baseWorldPos = new THREE.Vector3();
            const joint1WorldPos = new THREE.Vector3();
            const arm1WorldPos = new THREE.Vector3();
            const joint2WorldPos = new THREE.Vector3();
            const arm2WorldPos = new THREE.Vector3();
            const gripperWorldPos = new THREE.Vector3();
            
            base.getWorldPosition(baseWorldPos);
            joint1.getWorldPosition(joint1WorldPos);
            arm1.getWorldPosition(arm1WorldPos);
            joint2.getWorldPosition(joint2WorldPos);
            arm2.getWorldPosition(arm2WorldPos);
            gripper.getWorldPosition(gripperWorldPos);
            
            // Define collision distances for different parts
            const collisionDistances = {
                base: 2.0,
                joint: 1.0,
                arm: 1.2,
                gripper: 1.5
            };
            
            // Check collision with base
            if (cubePos.distanceTo(baseWorldPos) < collisionDistances.base) {
                return {
                    collision: true,
                    point: baseWorldPos,
                    type: 'base'
                };
            }
            
            // Check collision with joints
            for (const jointPos of [joint1WorldPos, joint2WorldPos]) {
                if (cubePos.distanceTo(jointPos) < collisionDistances.joint) {
                    return {
                        collision: true,
                        point: jointPos,
                        type: 'joint'
                    };
                }
            }
            
            // Check collision with arms (using line segments)
            const armSegments = [
                { start: joint1WorldPos, end: arm1WorldPos },
                { start: arm1WorldPos, end: joint2WorldPos },
                { start: joint2WorldPos, end: arm2WorldPos },
                { start: arm2WorldPos, end: gripperWorldPos }
            ];
            
            for (const segment of armSegments) {
                // Calculate closest point on line segment to cube
                const segmentVector = segment.end.clone().sub(segment.start);
                const length = segmentVector.length();
                segmentVector.normalize();
                
                const cubeToStart = cubePos.clone().sub(segment.start);
                const projection = cubeToStart.dot(segmentVector);
                
                let closestPoint;
                if (projection <= 0) {
                    closestPoint = segment.start.clone();
                } else if (projection >= length) {
                    closestPoint = segment.end.clone();
                } else {
                    closestPoint = segment.start.clone().add(segmentVector.multiplyScalar(projection));
                }
                
                if (cubePos.distanceTo(closestPoint) < collisionDistances.arm) {
                    return {
                        collision: true,
                        point: closestPoint,
                        type: 'arm'
                    };
                }
            }
            
            return { collision: false };
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            switch(phase) {
                case 'waiting':
                    if (!cube && !isControllingCube && Date.now() - lastSpawnTime >= CUBE_SPAWN_INTERVAL_MS) {
                        createRandomCube();
                        phase = 'tracking';
                        time = 0;
                    }
                    break;

                case 'tracking':
                    // Update all cubes with boundary checking
                    for (let i = cubes.length - 1; i >= 0; i--) {
                        const currentCube = cubes[i];
                        const physics = cubePhysicsStates[i];
                        
                        // Check if cube is out of bounds
                        if (isOutOfBounds(currentCube.position)) {
                            // Remove the cube from the scene and arrays
                            scene.remove(currentCube);
                            cubes.splice(i, 1);
                            cubePhysicsStates.splice(i, 1);
                            
                            // If the removed cube was the active cube, reset it
                            if (currentCube === cube) {
                                cube = null;
                                phase = 'waiting';
                            }
                            continue;
                        }

                        // Check for collision with robot arm
                        const collisionResult = checkArmCubeCollision(currentCube);
                        
                        if (collisionResult.collision) {
                            // Increment score when collision occurs
                            score++;
                            document.getElementById('scoreCounter').textContent = `Score: ${score}`;
                            
                            // Calculate collision response based on collision type
                            const collisionPoint = collisionResult.point;
                            const collisionVector = currentCube.position.clone().sub(collisionPoint).normalize();
                            
                            // Different bounce behaviors based on collision type
                            let bounceMultiplier = 1.0;
                            switch (collisionResult.type) {
                                case 'base':
                                    bounceMultiplier = 1.2;
                                    break;
                                case 'joint':
                                    bounceMultiplier = 0.8;
                                    break;
                                case 'arm':
                                    bounceMultiplier = 1.0;
                                    break;
                            }
                            
                            // Apply bounce effect
                            physics.velocity = -physics.velocity * COLLISION_DAMPING * bounceMultiplier;
                            
                            // Add horizontal velocity based on collision vector
                            physics.velocityX += collisionVector.x * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.velocityZ += collisionVector.z * ARM_BOUNCE_FORCE * bounceMultiplier;
                            
                            // Add spin based on collision point
                            physics.angularVelocity.x += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.angularVelocity.z += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.angularVelocity.y += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                        }
                        
                        // Apply gravity and update position with boundary checks
                        physics.velocity += GRAVITY;
                        currentCube.position.y -= physics.velocity;
                        
                        // Apply horizontal movement with boundary checks
                        const newX = currentCube.position.x + physics.velocityX;
                        const newZ = currentCube.position.z + physics.velocityZ;
                        
                        // Add boundary bouncing
                        if (newX < SCENE_BOUNDS.minX || newX > SCENE_BOUNDS.maxX) {
                            physics.velocityX = -physics.velocityX * 0.5; // Bounce with energy loss
                        } else {
                            currentCube.position.x = newX;
                        }
                        
                        if (newZ < SCENE_BOUNDS.minZ || newZ > SCENE_BOUNDS.maxZ) {
                            physics.velocityZ = -physics.velocityZ * 0.5; // Bounce with energy loss
                        } else {
                            currentCube.position.z = newZ;
                        }
                        
                        // Ground collision
                        if (currentCube.position.y <= 0) {
                            currentCube.position.y = 0;
                            if (Math.abs(physics.velocity) > 0.01) {
                                physics.velocity = -physics.velocity * GROUND_RESTITUTION;
                                
                                // Convert some of the vertical energy into rotation and horizontal movement
                                const horizontalEnergy = Math.abs(physics.velocity * 0.3);
                                physics.angularVelocity.x += (Math.random() - 0.5) * horizontalEnergy * ROTATION_FACTOR;
                                physics.angularVelocity.z += (Math.random() - 0.5) * horizontalEnergy * ROTATION_FACTOR;
                                
                                physics.velocityX *= FRICTION;
                                physics.velocityZ *= FRICTION;
                            }
                        }
                        
                        // Apply rotation
                        currentCube.rotation.x += physics.angularVelocity.x;
                        currentCube.rotation.y += physics.angularVelocity.y;
                        currentCube.rotation.z += physics.angularVelocity.z;
                        
                        // Damping for angular velocity
                        physics.angularVelocity.x *= ANGULAR_DAMPING;
                        physics.angularVelocity.y *= ANGULAR_DAMPING;
                        physics.angularVelocity.z *= ANGULAR_DAMPING;
                        
                        // Apply friction to horizontal movement
                        physics.velocityX *= FRICTION;
                        physics.velocityZ *= FRICTION;
                    }

                    // Only track the latest cube for robot arm movement if it exists and is in bounds
                    if (cube && !isOutOfBounds(cube.position)) {
                        // Only predict interception for cubes that haven't hit the ground
                        if (cube.position.y > 0) {
                            const interceptPoint = predictInterceptionPoint(
                                cube.position.clone(),
                                cubeVelocity
                            );
                            
                            const angles = solveIK(interceptPoint.x, interceptPoint.y, interceptPoint.z);
                            
                            base.rotation.y += (angles.baseAngle - base.rotation.y) * 0.08;
                            joint1.rotation.x += (angles.arm1Angle - joint1.rotation.x) * 0.08;
                            joint2.rotation.x += (angles.arm2Angle - joint2.rotation.x) * 0.08;
                        }

                        // Check if it's time to spawn a new cube
                        if (Date.now() - lastSpawnTime >= CUBE_SPAWN_INTERVAL_MS) {
                            createRandomCube();
                        }
                    } else {
                        phase = 'waiting';
                    }
                    break;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Function to set cube spawn rate
        function setCubeSpawnRate(secondsInterval) {
            cubeSpawnInterval = secondsInterval * 1000; // Convert to milliseconds
        }

        // Create a canvas for the text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;
        context.font = '48px Arial';
        context.fillStyle = 'white';

        // Create a texture from the canvas
        const texture = new THREE.CanvasTexture(canvas);
        const textMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const textGeometry = new THREE.PlaneGeometry(10, 2.5);
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);

        // Position the text on the ground and rotate it to face the camera
        textMesh.position.set(10, 0.1, -10); // Adjust position as needed
        textMesh.rotation.y = Math.PI / 4; // Rotate text to face the camera
        scene.add(textMesh);

        const messages = [
            "Hi🤗 I'm Guanxing Lu",
            "MS at THU@SZ🎓",
            "I like robots🤖",
            "I like trial and error🥝",
            "I like friends🥳",
            "I believe in miracles."
        ];
        let messageIndex = 0;
        let charIndex = 0;
        let isDeleting = false;

        function animateText() {
            const currentMessage = messages[messageIndex];
            
            if (isDeleting) {
                // Deleting text
                charIndex--;
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.fillText(currentMessage.substring(0, charIndex), 10, 60);
            } else {
                // Typing text
                charIndex++;
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.fillText(currentMessage.substring(0, charIndex), 10, 60);
            }
            
            texture.needsUpdate = true;
            
            // Change state when reaching end or start of text
            if (!isDeleting && charIndex === currentMessage.length) {
                // Pause at the end of typing
                setTimeout(() => {
                    isDeleting = true;
                }, 1500);
            } else if (isDeleting && charIndex === 0) {
                isDeleting = false;
                messageIndex = (messageIndex + 1) % messages.length;
            }
            
            // Set timing for next frame
            const delta = isDeleting ? 100 : 200;
            setTimeout(animateText, delta);
        }

        // Start the animation
        animateText();

        // Add event listeners for controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !isControllingCube) {
                event.preventDefault();
                isControllingCube = true;
                phase = 'waiting';
                if (cube) {
                    scene.remove(cube);
                    cubes = cubes.filter(c => c !== cube);
                    cube = null;
                }
            }
        });

        document.addEventListener('mousemove', (event) => {
            if (isControllingCube) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ground);
                
                if (intersects.length > 0) {
                    mousePosition.copy(intersects[0].point);
                    mousePosition.y = 10; // Height above ground
                    
                    if (cube) {
                        cube.position.copy(mousePosition);
                    } else {
                        createRandomCube();
                    }
                }
            }
        });

        document.addEventListener('click', () => {
            if (isControllingCube && cube) {
                isControllingCube = false;
                phase = 'tracking';
                lastSpawnTime = Date.now();
            }
        });

        animate();

        // Navigation functionality
        document.querySelectorAll('.nav-button').forEach(button => {
            button.addEventListener('click', () => {
                // Hide all sections
                document.querySelectorAll('.content-section').forEach(section => {
                    section.style.display = 'none';
                });
                
                // Remove active class from all buttons
                document.querySelectorAll('.nav-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Show selected section and activate button
                const sectionId = button.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'block';
                    button.classList.add('active');
                }
            });
        });
        
        // Close sections when clicking outside
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.content-section') && 
                !event.target.closest('.nav-button')) {
                document.querySelectorAll('.content-section').forEach(section => {
                    section.style.display = 'none';
                });
                document.querySelectorAll('.nav-button').forEach(btn => {
                    btn.classList.remove('active');
                });
            }
        });
    </script>
</body>
</html>
