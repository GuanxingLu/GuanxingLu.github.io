<!DOCTYPE html>
<html>
<head>
    <title>Robot Arm Simulation</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #scoreCounter {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="scoreCounter">Score: 0</div>
    <div id="instructions" style="position: fixed; top: 50px; left: 20px; color: white; font-family: Arial, sans-serif; z-index: 100;">
        Press SPACE to spawn cube<br>
        Move mouse to position cube<br>
        Click to drop cube
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x404040); // Gray background
        document.body.appendChild(renderer.domElement);

        // Lights
        const light = new THREE.DirectionalLight(0xffffff, 1.5); // Increased intensity
        light.position.set(50, 100, 50); // Higher position for sun-like effect
        light.castShadow = true; // Enable shadow casting
        light.shadow.mapSize.width = 2048; // Higher resolution shadows
        light.shadow.mapSize.height = 2048;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 500;
        light.shadow.camera.left = -50;
        light.shadow.camera.right = 50;
        light.shadow.camera.top = 50;
        light.shadow.camera.bottom = -50;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Enable shadow rendering in renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Robot arm parts with longer segments
        const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 2, 1, 32),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        scene.add(base);

        const joint1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 32, 32),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        joint1.position.y = 0.5;
        base.add(joint1);

        const arm1 = new THREE.Mesh(
            new THREE.BoxGeometry(1, 8, 1),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        arm1.position.y = 4; // Center of the arm
        joint1.add(arm1);

        const joint2 = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 32, 32),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        joint2.position.y = 4;
        arm1.add(joint2);

        const arm2 = new THREE.Mesh(
            new THREE.BoxGeometry(1, 6, 1),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        arm2.position.y = 3;
        joint2.add(arm2);

        // Gripper
        const gripper = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 2),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        gripper.position.y = 3; // Adjusted position
        arm2.add(gripper);

        // Camera position
        camera.position.set(10, 5, 10); // Adjust these values as needed
        camera.lookAt(0, 0, 0); // Ensure the camera is looking at the center of the scene

        // Hyper-parameters
        const ARM1_LENGTH = 8;
        const ARM2_LENGTH = 6;
        const GRAVITY = 0.002;
        const CUBE_SPAWN_INTERVAL_MS = 2000;
        const ARM_BOUNCE_FORCE = 0.2;
        const COLLISION_DAMPING = 0.7;

        // Animation variables
        let cube = null;
        let phase = 'waiting';
        let time = 0;
        let cubeVelocity = 0;
        let lastSpawnTime = 0; // Last cube spawn time
        let score = 0;

        // Add after the lights setup
        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(40, 40);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x808080,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true; // Enable shadow receiving
        scene.add(ground);

        // Update constants
        const GROUND_RESTITUTION = 0.6; // Bounce factor for ground collision
        const FRICTION = 0.98; // Friction for horizontal movement
        const ANGULAR_DAMPING = 0.98; // Damping for rotation
        const ROTATION_FACTOR = 0.1; // Factor for converting linear to angular velocity

        // Add these variables to track horizontal movement
        let cubeVelocityX = 0;
        let cubeVelocityZ = 0;

        // Add these variables to track cube physics
        let cubeAngularVelocity = {
            x: 0,
            y: 0,
            z: 0
        };

        // Update robot arm parts to cast shadows
        base.castShadow = true;
        joint1.castShadow = true;
        arm1.castShadow = true;
        joint2.castShadow = true;
        arm2.castShadow = true;
        gripper.castShadow = true;

        // Add these constants and variables for cube management
        const MAX_CUBES = 5; // Maximum number of cubes allowed in the scene
        let cubes = []; // Array to store all active cubes
        let cubePhysicsStates = []; // Array to store physics states for each cube

        // Add these constants for scene boundaries
        const SCENE_BOUNDS = {
            minX: -20,
            maxX: 20,
            minY: -10,
            maxY: 20,
            minZ: -20,
            maxZ: 20
        };

        // Add this function to check if a cube is out of bounds
        function isOutOfBounds(position) {
            return position.x < SCENE_BOUNDS.minX || position.x > SCENE_BOUNDS.maxX ||
                   position.y < SCENE_BOUNDS.minY || position.y > SCENE_BOUNDS.maxY ||
                   position.z < SCENE_BOUNDS.minZ || position.z > SCENE_BOUNDS.maxZ;
        }

        // Add new control variables
        let isControllingCube = false;
        let mousePosition = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modify createRandomCube function
        function createRandomCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            const newCube = new THREE.Mesh(geometry, material);
            
            if (!isControllingCube) {
                // Original random position logic
                const innerRadius = 2;
                const outerRadius = 4;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * (outerRadius - innerRadius) + innerRadius;
                newCube.position.set(
                    Math.cos(angle) * radius,
                    10,
                    Math.sin(angle) * radius
                );
            } else {
                // Position at mouse location
                newCube.position.copy(mousePosition);
            }
            
            newCube.castShadow = true;
            
            // Add new cube physics state
            const physicsState = {
                velocity: 0,
                velocityX: 0,
                velocityZ: 0,
                angularVelocity: { x: 0, y: 0, z: 0 }
            };

            // Remove oldest cube if we've reached the limit
            if (cubes.length >= MAX_CUBES) {
                scene.remove(cubes[0]);
                cubes.shift();
                cubePhysicsStates.shift();
            }

            // Add new cube
            cubes.push(newCube);
            cubePhysicsStates.push(physicsState);
            scene.add(newCube);
            
            // Set the active cube as the newest one
            cube = newCube;
            cubeVelocity = 0;
            cubeVelocityX = 0;
            cubeVelocityZ = 0;
            cubeAngularVelocity = { x: 0, y: 0, z: 0 };
            
            lastSpawnTime = Date.now();
        }

        // Two-joint IK solver
        function solveIK(targetX, targetY, targetZ) {
            // Convert target to local coordinates
            const dx = Math.sqrt(targetX * targetX + targetZ * targetZ);
            const dy = targetY - 3.5; // Adjust for base height
            
            // Calculate angles using cosine law
            const targetDist = Math.sqrt(dx * dx + dy * dy);
            
            // Prevent over-extension
            const maxReach = ARM1_LENGTH + ARM2_LENGTH;
            if (targetDist > maxReach) {
                const scale = maxReach / targetDist;
                targetDist *= scale;
            }

            const cosAngle2 = (targetDist * targetDist - ARM1_LENGTH * ARM1_LENGTH - ARM2_LENGTH * ARM2_LENGTH) / 
                             (2 * ARM1_LENGTH * ARM2_LENGTH);
            
            // Calculate joint angles
            const angle2 = Math.acos(Math.min(1, Math.max(-1, cosAngle2)));
            const angle1 = Math.atan2(dy, dx) - 
                          Math.atan2(ARM2_LENGTH * Math.sin(angle2),
                                   ARM1_LENGTH + ARM2_LENGTH * Math.cos(angle2));

            return {
                baseAngle: Math.atan2(targetX, targetZ),
                arm1Angle: -angle1,
                arm2Angle: -angle2
            };
        }

        // Predict interception point
        function predictInterceptionPoint(cubePos, cubeVel) {
            // Simple prediction - you can make this more sophisticated
            const timeToIntercept = Math.sqrt(2 * cubePos.y / GRAVITY);
            return new THREE.Vector3(
                cubePos.x,
                Math.max(1, cubePos.y - (cubeVel * timeToIntercept + 0.5 * GRAVITY * timeToIntercept * timeToIntercept)),
                cubePos.z
            );
        }

        // Enhanced collision detection helper function
        function checkArmCubeCollision(cube) {
            const cubePos = cube.position;
            const collisionPoints = [];
            
            // Get world positions of all arm segments
            const baseWorldPos = new THREE.Vector3();
            const joint1WorldPos = new THREE.Vector3();
            const arm1WorldPos = new THREE.Vector3();
            const joint2WorldPos = new THREE.Vector3();
            const arm2WorldPos = new THREE.Vector3();
            const gripperWorldPos = new THREE.Vector3();
            
            base.getWorldPosition(baseWorldPos);
            joint1.getWorldPosition(joint1WorldPos);
            arm1.getWorldPosition(arm1WorldPos);
            joint2.getWorldPosition(joint2WorldPos);
            arm2.getWorldPosition(arm2WorldPos);
            gripper.getWorldPosition(gripperWorldPos);
            
            // Define collision distances for different parts
            const collisionDistances = {
                base: 2.0,
                joint: 1.0,
                arm: 1.2,
                gripper: 1.5
            };
            
            // Check collision with base
            if (cubePos.distanceTo(baseWorldPos) < collisionDistances.base) {
                return {
                    collision: true,
                    point: baseWorldPos,
                    type: 'base'
                };
            }
            
            // Check collision with joints
            for (const jointPos of [joint1WorldPos, joint2WorldPos]) {
                if (cubePos.distanceTo(jointPos) < collisionDistances.joint) {
                    return {
                        collision: true,
                        point: jointPos,
                        type: 'joint'
                    };
                }
            }
            
            // Check collision with arms (using line segments)
            const armSegments = [
                { start: joint1WorldPos, end: arm1WorldPos },
                { start: arm1WorldPos, end: joint2WorldPos },
                { start: joint2WorldPos, end: arm2WorldPos },
                { start: arm2WorldPos, end: gripperWorldPos }
            ];
            
            for (const segment of armSegments) {
                // Calculate closest point on line segment to cube
                const segmentVector = segment.end.clone().sub(segment.start);
                const length = segmentVector.length();
                segmentVector.normalize();
                
                const cubeToStart = cubePos.clone().sub(segment.start);
                const projection = cubeToStart.dot(segmentVector);
                
                let closestPoint;
                if (projection <= 0) {
                    closestPoint = segment.start.clone();
                } else if (projection >= length) {
                    closestPoint = segment.end.clone();
                } else {
                    closestPoint = segment.start.clone().add(segmentVector.multiplyScalar(projection));
                }
                
                if (cubePos.distanceTo(closestPoint) < collisionDistances.arm) {
                    return {
                        collision: true,
                        point: closestPoint,
                        type: 'arm'
                    };
                }
            }
            
            return { collision: false };
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            switch(phase) {
                case 'waiting':
                    if (!cube && !isControllingCube && Date.now() - lastSpawnTime >= CUBE_SPAWN_INTERVAL_MS) {
                        createRandomCube();
                        phase = 'tracking';
                        time = 0;
                    }
                    break;

                case 'tracking':
                    // Update all cubes with boundary checking
                    for (let i = cubes.length - 1; i >= 0; i--) {
                        const currentCube = cubes[i];
                        const physics = cubePhysicsStates[i];
                        
                        // Check if cube is out of bounds
                        if (isOutOfBounds(currentCube.position)) {
                            // Remove the cube from the scene and arrays
                            scene.remove(currentCube);
                            cubes.splice(i, 1);
                            cubePhysicsStates.splice(i, 1);
                            
                            // If the removed cube was the active cube, reset it
                            if (currentCube === cube) {
                                cube = null;
                                phase = 'waiting';
                            }
                            continue;
                        }

                        // Check for collision with robot arm
                        const collisionResult = checkArmCubeCollision(currentCube);
                        
                        if (collisionResult.collision) {
                            // Increment score when collision occurs
                            score++;
                            document.getElementById('scoreCounter').textContent = `Score: ${score}`;
                            
                            // Calculate collision response based on collision type
                            const collisionPoint = collisionResult.point;
                            const collisionVector = currentCube.position.clone().sub(collisionPoint).normalize();
                            
                            // Different bounce behaviors based on collision type
                            let bounceMultiplier = 1.0;
                            switch (collisionResult.type) {
                                case 'base':
                                    bounceMultiplier = 1.2;
                                    break;
                                case 'joint':
                                    bounceMultiplier = 0.8;
                                    break;
                                case 'arm':
                                    bounceMultiplier = 1.0;
                                    break;
                            }
                            
                            // Apply bounce effect
                            physics.velocity = -physics.velocity * COLLISION_DAMPING * bounceMultiplier;
                            
                            // Add horizontal velocity based on collision vector
                            physics.velocityX += collisionVector.x * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.velocityZ += collisionVector.z * ARM_BOUNCE_FORCE * bounceMultiplier;
                            
                            // Add spin based on collision point
                            physics.angularVelocity.x += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.angularVelocity.z += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                            physics.angularVelocity.y += (Math.random() - 0.5) * ARM_BOUNCE_FORCE * bounceMultiplier;
                        }
                        
                        // Apply gravity and update position with boundary checks
                        physics.velocity += GRAVITY;
                        currentCube.position.y -= physics.velocity;
                        
                        // Apply horizontal movement with boundary checks
                        const newX = currentCube.position.x + physics.velocityX;
                        const newZ = currentCube.position.z + physics.velocityZ;
                        
                        // Add boundary bouncing
                        if (newX < SCENE_BOUNDS.minX || newX > SCENE_BOUNDS.maxX) {
                            physics.velocityX = -physics.velocityX * 0.5; // Bounce with energy loss
                        } else {
                            currentCube.position.x = newX;
                        }
                        
                        if (newZ < SCENE_BOUNDS.minZ || newZ > SCENE_BOUNDS.maxZ) {
                            physics.velocityZ = -physics.velocityZ * 0.5; // Bounce with energy loss
                        } else {
                            currentCube.position.z = newZ;
                        }
                        
                        // Ground collision
                        if (currentCube.position.y <= 0) {
                            currentCube.position.y = 0;
                            if (Math.abs(physics.velocity) > 0.01) {
                                physics.velocity = -physics.velocity * GROUND_RESTITUTION;
                                
                                // Convert some of the vertical energy into rotation and horizontal movement
                                const horizontalEnergy = Math.abs(physics.velocity * 0.3);
                                physics.angularVelocity.x += (Math.random() - 0.5) * horizontalEnergy * ROTATION_FACTOR;
                                physics.angularVelocity.z += (Math.random() - 0.5) * horizontalEnergy * ROTATION_FACTOR;
                                
                                physics.velocityX *= FRICTION;
                                physics.velocityZ *= FRICTION;
                            }
                        }
                        
                        // Apply rotation
                        currentCube.rotation.x += physics.angularVelocity.x;
                        currentCube.rotation.y += physics.angularVelocity.y;
                        currentCube.rotation.z += physics.angularVelocity.z;
                        
                        // Damping for angular velocity
                        physics.angularVelocity.x *= ANGULAR_DAMPING;
                        physics.angularVelocity.y *= ANGULAR_DAMPING;
                        physics.angularVelocity.z *= ANGULAR_DAMPING;
                        
                        // Apply friction to horizontal movement
                        physics.velocityX *= FRICTION;
                        physics.velocityZ *= FRICTION;
                    }

                    // Only track the latest cube for robot arm movement if it exists and is in bounds
                    if (cube && !isOutOfBounds(cube.position)) {
                        // Only predict interception for cubes that haven't hit the ground
                        if (cube.position.y > 0) {
                            const interceptPoint = predictInterceptionPoint(
                                cube.position.clone(),
                                cubeVelocity
                            );
                            
                            const angles = solveIK(interceptPoint.x, interceptPoint.y, interceptPoint.z);
                            
                            base.rotation.y += (angles.baseAngle - base.rotation.y) * 0.08;
                            joint1.rotation.x += (angles.arm1Angle - joint1.rotation.x) * 0.08;
                            joint2.rotation.x += (angles.arm2Angle - joint2.rotation.x) * 0.08;
                        }

                        // Check if it's time to spawn a new cube
                        if (Date.now() - lastSpawnTime >= CUBE_SPAWN_INTERVAL_MS) {
                            createRandomCube();
                        }
                    } else {
                        phase = 'waiting';
                    }
                    break;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Function to set cube spawn rate
        function setCubeSpawnRate(secondsInterval) {
            cubeSpawnInterval = secondsInterval * 1000; // Convert to milliseconds
        }

        // Create a canvas for the text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;
        context.font = '48px Arial';
        context.fillStyle = 'white';

        // Create a texture from the canvas
        const texture = new THREE.CanvasTexture(canvas);
        const textMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const textGeometry = new THREE.PlaneGeometry(10, 2.5);
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);

        // Position the text on the ground and rotate it to face the camera
        textMesh.position.set(10, 0.1, -10); // Adjust position as needed
        textMesh.rotation.y = Math.PI / 4; // Rotate text to face the camera
        scene.add(textMesh);

        // Animate text appearance
        let charIndex = 0;
        const textString = "HiðŸ¤— I'm Guanxing Lu";
        const interval = setInterval(() => {
            if (charIndex <= textString.length) {
                context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                context.fillText(textString.substring(0, charIndex), 10, 60);
                texture.needsUpdate = true; // Update texture
                charIndex++;
            } else {
                clearInterval(interval);
            }
        }, 200); // Adjust typing speed as needed

        // Add event listeners for controls
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !isControllingCube) {
                event.preventDefault();
                isControllingCube = true;
                phase = 'waiting';
                if (cube) {
                    scene.remove(cube);
                    cubes = cubes.filter(c => c !== cube);
                    cube = null;
                }
            }
        });

        document.addEventListener('mousemove', (event) => {
            if (isControllingCube) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ground);
                
                if (intersects.length > 0) {
                    mousePosition.copy(intersects[0].point);
                    mousePosition.y = 10; // Height above ground
                    
                    if (cube) {
                        cube.position.copy(mousePosition);
                    } else {
                        createRandomCube();
                    }
                }
            }
        });

        document.addEventListener('click', () => {
            if (isControllingCube && cube) {
                isControllingCube = false;
                phase = 'tracking';
                lastSpawnTime = Date.now();
            }
        });

        animate();
    </script>
</body>
</html>
